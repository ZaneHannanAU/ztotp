{"version":3,"file":"zbigtotp.js","sourceRoot":"","sources":["../src/zbigtotp.ts"],"names":[],"mappings":"","sourcesContent":["// import { createHmac } from 'crypto'\n// \n// export const bigMs = 1_000n\n// \n// export const verifiableRanges:bigint[][] = [\n// \t[0n],\n// \t[0n, -1n],\n// \t[0n, -1n, -2n, -3n],\n// \t[0n, -1n, -2n, -3n, -4n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n, -9n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n, -9n, -10n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n, -9n, -10n, -11n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n, -9n, -10n, -11n, -12n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n, -9n, -10n, -11n, -12n, -13n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n, -9n, -10n, -11n, -12n, -13n, -14n],\n// \t[0n, -1n, -2n, -3n, -4n, -5n, -6n, -7n, -8n, -9n, -10n, -11n, -12n, -13n, -14n, -15n]\n// ]\n// export const verifiableRange:bigint[] = verifiableRanges[2]\n// \n// export const bigTruncate:BigUint64Array = BigUint64Array.of(\n// \t1n,\n// \t10n,\n// \t100n,\n// \t1_000n,\n// \t10_000n,\n// \t100_000n,\n// \t1_000_000n,\n// \t10_000_000n,\n// \t100_000_000n,\n// \t1_000_000_000n,\n// \t10_000_000_000n,\n// \t100_000_000_000n,\n// \t1_000_000_000_000n,\n// \t10_000_000_000_000n,\n// \t100_000_000_000_000n,\n// \t1_000_000_000_000_000n,\n// \t10_000_000_000_000_000n,\n// \t100_000_000_000_000_000n,\n// \t1_000_000_000_000_000_000n,\n// \t10_000_000_000_000_000_000n\n// )\n// // JSON.stringify(Array.from({length:20},($,n)=>Math.pow(10, n)), null, '\\t').replace(/(10+)/g, nf.format).replace(/,([^\\n])/g, '_$1').replace(/(0)$|(,)$/gm, '$1n$2').replace('[','BigUint64Array.of(').replace(']',')')\n// \n// export const bigReadOut = (b:ArrayBufferView):bigint => {\n// \tconst dv = new DataView(b.buffer, b.byteOffset, b.byteLength)\n// \tconst offset = dv.getUint8(dv.byteLength - 1) & 15\n// \treturn dv.getBigUint64(offset, true)\n// }\n// \n// export function getBigTOTP(\n// \tsecret:ArrayBufferView,\n// \tdate:bigint = BigInt(Date.now()),\n// \tlength:number|bigint = 9n,\n// \talgorithm:string = 'sha256',\n// \tT0:bigint = 0n,\n// \tTI:bigint = 30n\n// ):bigint {\n// \tconst TC:BigInt64Array = BigInt64Array.of((date - T0 * bigMs) / (bigMs * TI))\n// \n// \tconst TOTP:bigint = bigReadOut(\n// \t\tcreateHmac(alg, secret)\n// \t\t.update(TC)\n// \t\t.digest\n// \t)\n// \n// \tconst TOTPValue = TOTP % bigTruncate[length]\n// }\n// \n// export const getBigTOTPShort = (s:ArrayBufferView, len:number | bigint, alg:string) => getTOTP(s, undefined, len, alg)\n// \n// export const getBigTOTPString = (s:ArrayBufferView, len:number | bigint, alg:string) => String(getTOTPShort(s, len, alg))\n// \t.padStart(len, '0')\n// \n// export function verifyBigTOTP (\n// \tinput: bigint | string,\n// \tsecret:ArrayBufferView,\n// \trange:bigint[] | number | bigint = verifiableRange,\n// \tdate:bigint = BigInt(Date.now()),\n// \tlen:bigint|number = 6,\n// \talg:string = 'sha1',\n// \tT0:bigint = 0n,\n// \tTI:bigint = 30n\n// ):boolean {\n// \tconst value:bigint = 'bigint' !== typeof input\n// \t\t? BigInt(input.replace(/\\D+/g, ''), 10)\n// \t\t: input\n// \n// \tconst verifiable:bigint[] = Array.isArray(range)\n// \t\t? range\n// \t\t: verifiableRanges[range]\n// \n// \tconst get = (T_:number):number => getTOTP(\n// \t\tsecret,\n// \t\tdate,\n// \t\tlen,\n// \t\talg,\n// \t\tT_,\n// \t\tTI\n// \t)\n// \tlet matched = false\n// \tfor (const diff of verifiable)\n// \t\tif (get(T0 + diff * TI) === value)\n// \t\t\tmatched = true\n// \n// \treturn matched\n// }\n"]}