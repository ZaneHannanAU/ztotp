{"version":3,"file":"ztotp.js","sourceRoot":"","sources":["../src/ztotp.ts"],"names":[],"mappings":"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","sourcesContent":["import { createHmac } from 'crypto'\n\nexport const ms = 1_000\nexport const _31 = Math.pow(2, 31) - 1\n\nexport const fullVerifiableRange:Int8Array = Int8Array.of(0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15)\nexport const getVerifiableRange = (r:number) => new Int8Array(fullVerifiableRange.buffer, fullVerifiableRange.byteOffset, r + 1)\nexport const verifiableRange:number[] | Int8Array = getVerifiableRange(2)\nexport function padStart(s:string, len:number, w:string = ' ') {\n\twhile (s.length < len)\n\t\ts = w + s\n\treturn s\n}\n\nexport const truncate:Uint32Array = Uint32Array.of(\n\t1,\n\t10,\n\t100,\n\t1_000,\n\t10_000,\n\t100_000,\n\t1_000_000,\n\t10_000_000,\n\t100_000_000,\n\t1_000_000_000\n)\n\nexport const readOut = (b:Buffer)=>b.readInt32BE(b[b.length-1]&15)&_31\n// same as before just no logging\n\n/**\n * @func getTOTP\n * @arg {buffer} secret binary key (required).\n * @arg {number} date time in milliseconds (optional, default `Date.now()`).\n * @arg {number} length of value to generate (optional, default `6`).\n * @arg {string} algorithm to digest with (optional, default `'sha1'`).\n * @arg {number} T0 as time offset in seconds (optional, default `0`).\n * @arg {number} TI as time increment in seconds (optional, default `30`).\n * @returns {number} signed positive 32 bit integer.\n *\n */\nexport function getTOTP(\n\tsecret:Buffer,\n\tdate:number = Date.now(),\n\tlength = 6,\n\talgorithm:string = 'sha1',\n\tT0:number = 0,\n\tTI:number = 30\n):number {\n\tconst TC:string = padStart(\n\t\tMath.floor((date - T0 * ms) / (ms * TI)).toString(16),\n\t\t16,\n\t\t'0'\n\t)\n\n\tconst TOTP:number = readOut(\n\t\tcreateHmac(algorithm, secret)\n\t\t.update(Buffer.from(TC, 'hex'))\n\t\t.digest()\n\t)\n\t\n\tconst TOTPValue = TOTP % truncate[length]\n\treturn TOTPValue\n}\n\n\nexport const getTOTPShort = (s:Buffer, len:number, alg:string) => getTOTP(s, undefined, len, alg)\nexport const getTOTPString = (s:Buffer, len:number, alg:string) => padStart(String(getTOTPShort(s, len, alg)), len, '0')\n//.padStart(len, '0')\n\nexport function verifyTOTP (\n\tinput: number | string,\n\tsecret:Buffer,\n\trange:number[] | number | Int8Array = verifiableRange,\n\tdate:number = Date.now(),\n\tlen:number = 6,\n\talg:string = 'sha1',\n\tT0:number = 0,\n\tTI:number = 30\n):boolean {\n\tconst value:number = 'number' !== typeof input\n\t\t? parseInt(input.replace(/\\D+/g, ''), 10)\n\t\t: Math.floor(input) === input ? input : -1\n\n\tconst verifiable:number[] | Int8Array = 'number' === typeof range\n\t\t? getVerifiableRange(range)\n\t\t: range\n\n\tconst get = (T_:number):number => getTOTP(\n\t\tsecret,\n\t\tdate,\n\t\tlen,\n\t\talg,\n\t\tT_,\n\t\tTI\n\t)\n\tlet matched = 0\n\tfor (const diff of verifiable)\n\t\tif (get(T0 + diff * TI) === value)\n\t\t\tmatched++\n\n\treturn !!matched\n}\nexport {\n\tverifyTOTP as isValid,\n\tverifyTOTP as validate,\n\tverifyTOTP as getValidity\n}\n\nexport * from './totp-uri'\n\n"]}